#
# Obligatorisk oppgave 3

## Deloppgave 1: Team og prosjekt

### Roller i teamet

Siden sist har vi egentlig ikke lagt stort merke til rollene vi i utgangspunktet bestemte oss for (gruppeleder og kundekontakt). Alle tar mer eller mindre initiativ til å avtale fremtidige møter. Når det gjelder avgjørende spørsmål om design og løsningsmetode, tar vi det opp i plenum på møtene. Det har liksom ikke vært naturlig for gruppeleder å ta en sjefsavgjørelse noe sted, siden vi har vært flinke på å ta slike avgjørelser kollektivt. Kundekontakten vår har ikke hatt kontakt med &quot;kunden&quot; i det hele tatt. Vi var under oppfatning at  kontaktlærer skulle &quot;skuespille&quot; en kunde med egne ønsker og behov, men det viste seg å bære være en mulighet til å få svar på eventuelle spørsmål fra kontaktlærer. Vi har egentlig ikke støtt på noen problemer hvor vi har følt at det kan være verdt å få kontaktlærer sin input på.

Likevel velger vi enda å beholde de rollene vi har nå. Hvorfor? Om det ikke er av god gammeldags tradisjon så er det gjerne i tilfelle det skulle oppstå en situasjon, gjerne behov for en sjefsavgjørelse eller et kundemøte, hvor vi kunne trengt en person som har hovedansvaret for situasjonen. Basert på hvordan vi har klart oss til nå anser vi dette som lite sannsynlig, og det må nevnes at ingen på gruppen tar rollene veldig seriøst i praksis.

Vi har heller ikke noe behov på å gjøre om på rollene, ettersom rollene har så liten grad av betydning i praksis, som allerede diskutert. Vi har heller ikke valgt å introdusert nye roller enda, da vi ikke har sett noe behov for det. Som nevnt sist har vi lekt med tanken om å utpeke en som hovedansvarlig for grafisk design, en idé vi ikke har lagt fra oss, men som vi heller tar som det kommer. Foreløpig klarer vi oss med den standard grafikken fra siden på Mitt Uib.

### Refleksjon: erfaringer og valg

Under de siste to sprintene har vi virkelig brukt project boardet med Issues på GitHub for alt det er verdt. Issues-funksjoner er veldig handy, spesielt tags og assignment. Vi også begynt opprettet milestones til hver sprint, slik at vi enkelt kan identifisere hvilken sprint en arbeidsoppgave tilhører. Samtlige i gruppen har blitt veldig dreven på å holde project boardet oppdatert, og vi opplever det nå veldig oversiktlig. Kommer vi på en praktisk feature som strengt tatt ikke er nødvendig eller noe som blir viktig snart, legger vi det gjerne i backloggen. I tillegg oppretter vi egne issues på større bugs, for å informere resten av gruppen om det.

Etter å ha begynt med å tildele arbeidsoppgaver til enkelte gruppemedlemmer, har vi også opplevd at arbeidsdeltakelsen har fordelt seg jevnere blant gruppemedlemmene. I tillegg er det nå mye mindre tvil om hvem som gjør hva til enhver tid. Dette har virkelig hjulpet oss i organiseringsproblemene vi har opplevd tidligere i gruppearbeidet.

Som nevnt i forrige rapport har vi fokusert på å implementere alle funksjonene på brettet først og fremst. Nå er vi egentlig i mål der, og vi føler at vi nærmer oss et liknende MVP. Vi er enige om at det var et lurt valg å prioritere det; det helhetlige oppgaven føles ikke lengre så overveldende stor, og det har gitt gruppen et slags &quot;we can do it&quot;-momentum. Forhåpentligvis kan vi ta med oss dette i ukene som kommer.

I forrige oblig nevnte vi også et ønske om spesielt testdrevet utvikling og parprogrammering som en sentral del av arbeidsmetoden vår.

Noe av det første vi gjorde i sprint 2 (første sprintet siden sist innlevering) var å løse headless-problemet, slik at testing var mulig. Dette var forresten en av forbedringspunktene våres under forrige innlevering. Siden den gang har arbeidsmetoden vår stort sett basert seg på testdrevet utvikling, med noen unntak. Vi har litt delte meninger om testdrevet utvikling. Enkelte gruppemedlemmer synes det det er hjelpsomt, spesielt får det man til å utvikle godt lesbare klasse- og metodenavn i tillegg til å få frem akkurat den funksjonaliteten man behøver. Andre medlemmer synes det er mer i veien, at noe man kunne utviklet på en halvtime fort tar to timer. Likevel er vi bestemt på å fortsette med denne metodikken, da vi er enige om at fordelene veier opp for ulempene.

Når det gjelder parprogrammering, har vi rett og slett blitt hindret i dette på grunn av den spesielle koronasituasjonen. I spesielt den siste uken har vi på en måte erstattet det med å samles i en gruppe på Discord å kode hver for oss, hvor terskelen er lav når det gjelder spørsmål om implementasjonsdetaljer. Slik får vi hele tiden andre sine inputs på egne kortsiktige og langsiktige planer.

### Retrospektiv

For to sprints tilbake i tid, altså ved innlevering av forrige obligatoriske oppgave, hadde vi egentlig landet på bruke scrum som prosjektmetodikk. Vi la også spesielt vekt på å opprette brukerhistorier på første møtet i sprintet, for å ha arbeidsoppgaver for sprintet klart definert allerede ved starten.

Dette har vi egentlig ikke klart å holde oss til: arbeidsoppgaver blir lagt til i project boardet kontinuerlig, det er ikke til å unngå. Vi har opplevd at det er ganske utfordrende å &quot;spå&quot; alle funksjonaliteter som vi kommer til å trenge to uker frem i tid. Dessuten føler vi at en slik arbeidsmetode er noe hindrene for fremgang; underveis innser vi gjerne uforutsette behov som heller bør prioriteres. Da har vi rett og slett bare prioritert det, men da blir de originale arbeidsoppgavene forskjøvet.

Vi ser ikke lengre på denne arbeidsmåten som noe vi bør unngå, men heller noe vi bør billedlig talt omfavne. Utfordringen sist var jo at en slik arbeidsmåte skapte forvirring og ubalanse i oppfatningen om hva retningen vår er. Men ved å bruke project boardet skikkelig med assignment og milestones, og generelt mer kommunikasjon på møtene, har ikke dette vist seg å være et problem lengre.

For eksempel måtte vi forskyve mange av arbeidsoppgavene fra sprint 2 inn i sprint 3, fordi de ble nedprioritert. Dermed fikk sprint 3 en spesiell start, med noen gamle og noen nye user stories. Men dette viste seg egentlig å gå overraskende bra. Vi bare kompenserte med å begrense mengden nye brukerhistorier i sprint 3. I skrivende stund er vi ferdig med arbeidskravene fra denne sprint 3, og klare til å starte på en ny.

Alt i alt har vi altså beveget oss noe vekk fra scrum og over i en kanban-lignende arbeidsmetodikk. Kanskje vi er et sted i midten? Vi synes vi har funnet et arbeidsmetode som funker for oss, og den går som følgende: første møtet i sprinten går til å utvikle brukerhistorier og arbeidsoppgaver, slik som før. Da har vi et godt utgangspunkt. Men vi er fleksible. Nye brukerhistorier og arbeidsoppgaver kan opprettes når som helst. Enkelte arbeidsoppgaver, spesielt små og spesifikke, trenger ikke å tilhøre en brukerhistorie. For å ikke skape forvirring bruker vi issues med assignments, milestones og tags, som nevnt ovenfor. Det er også viktig å kontinuerlig informere de andre gruppemedlemmene på møtene om nye tanker om oppgaver vi bør prioritere.

##### Forbedringspunkter fra retrospektiv

Basert på alt som er sagt til nå, har vi kommet frem til noen forbedringspunkter som vi vil jobbe mot i neste sprint. Det bør forsåvidt nevnes at vi er veldig fornøyde med måten vi jobber på nå, og å komme frem til forbedringspunkter har vært utfordrende i seg selv.

**Forbedringspunkter**

1. 1)Vi bør holde gruppemøter minst 2 ganger i uken, inkludert det obligatoriske møtet på fredager. Dette har vi ikke alltid vært så flinke til, og hyppige møter er spesielt viktig med tanke på vår prosjektmetodikk.
2. 2)Komme raskt i gang med en ny sprint etter avslutningen av den forrige. Og for å presisere: holde møtet hvor vi oppretter brukerhistorier like etter avslutningen av forrige sprint. Enkelte ganger har det gjerne gått en ukes mellomrom her. Det blir som et slags tomrom hvor ingen vet helt hva de skal gjøre.

##### Framtidsplaner og prioriteringer

Nå har vi funksjonalitet for så og si alt på brettet, i tillegg til fungerende programkort og en skjekk for win conditions. Dermed føler vi det nå er på tide å få implementert en prototypet rundebasert gang i spillet, slik at spillet faktisk begynner å ligne slik det er beskrevet i regelboken: spilleren skal kunne programmere roboten sin vha. et user interface hvor spilleren får sett kortene sine, og hvor bevegelsen skjer som et resultat av at kortet blir aktivert, i stedet for via piltastene. Mellom hver bevegelse skal brettet sine bevegelser osv.

Project boardet er vedlagt som bildefil.

#### Kommunikasjon og gruppedynamikk

Kommunikasjonen har vært relativt bra for denne iterasjonen. Det har så klart vært ganske utfordrende å kunne jobbe effektivt sammen etter at universitetet stengte ned og et par av oss dro fra Bergen, men vi har gjort så godt vi kan. Møtene våre har vi holdt over discord. Der kan vi snakke med hverandre, skrive spørsmål eller bruke skjermdeling. I begynnelsen av denne iterasjonen var det vanskelig å holde møter, ettersom coronaviruset nettopp hadde begynt å spre seg i bergen, men vi føler at vi har blitt mer effektive på kommunikasjonen nå mot slutten. Bare denne siste uken har vi hatt 4 ulike møter der vi har jobbet godt og planlagt hvordan vi skal gå fremover. I framtiden må vi nok fortsette med å holde møter ofte, ettersom det blir ekstra viktig med god og hyppig kommunikasjon nå som vi ikke kan møtes fysisk lengre, og med tanke på vår fleksible metodikk som nevnt.

## Deloppgave 2: Krav

Siden forrige gang har vi prioritert ytterligere funksjonalitet på brettet og litt spill logikk. Vi har implementert:

- --Conveyors
- --Gears
- --Skiftenøkler
- --Lasere
- --Dytte-vegger
- --Damage tokens
- --Life tokens
- --Programkort

Vi anser fortsatt MVP som det absolutte minimum av funksjonalitet som vi trenger for at spillet kan fungere, MVP er da:

- Et Kart som inneholder alle spill-objektene vi trenger for å spille RoboRally. Kartet må altså inneholde:
  - Vegger
  - Laser
  - Flag
  - Hull
  - Tannhjul
  - Transportbånd
  - Skiftenøkkel
  - Roboter
- En overordnet spill-klasse som behandler spill-logikk og viser kartet grafisk til brukeren.
- En Robot som kan
  - Bevege seg
  - Miste liv
  - Dø
  - Gjennoppstå
  - Powerdown
- En spiller som kan:
  - Få utdelt programkort
  - Legge ned et program
  - Tape/vinne
- Brukergrensesnitt som lar brukeren:
  - Se spill-brettet grafisk
  - programmere roboten sin
  - velge powerdown
- Rammeverk for lokal multiplayer

##### Bugs

Fram til nå har vi støtt på en del bugs, men har som regel fikset disse så snart de har dukket opp. Bugs som fremdeles fins i koden er:

- Dersom den aktive spilleren mister alt livet sitt og blir fjernet fra kartet, vil spillet fortsatt prøve å flytte på spilleren når bevegelses tastene blir trykket. Dette fører til en nullpointer exception.
- Dersom en spiller dør mens lasere blir fyrt av vil laserene ikke forsvinne fra kartet. Dette er fordi inputadapteren endrer seg midlertidig, og det er derfor ikke noen funksjon som fjerner laserene fra brettet igjen. Vi har ikke fikset denne bugen enda ettersom løsningen vår på laserene er ganske midlertidig, og vi antar at bugen vil bli fikset når vi lager en bedre løsning for laserene.
- Dersom en spiller blir dyttet inn i en vegg av et samlebånd med rotasjon, vil spilleren stå i ro og rotere. Dette er ikke blitt fikset enda da vi er usikre på om dette er ønsket oppførsel eller ikke.
- Når spiller avsluttes ved å trykke på exit-knappen vil det forårsake en error

## Deloppgave 3: Produktleveranse og kodekvalitet

**For informasjon om bygging, testing og kjøring, se README.md**

#### Manuelle tester

**Kort**
For øyeblikket har vi valgt å kommentere ut den enkle HUD skjermen vi har laget. Slik det er implementert nå (midlertidig implementasjon som skal endres) overskriver HUD skjermen inputprosessoren fra game klassen. Derfor blir veldig knotete og tungvint å kjøre manuelle tester på den måten. Men allikevel har implementasjonen av HUD skjermen lært oss veldig mye om hvor vi skal gå framover og vi har noen veldig enkle manuelle tester:

For det første må HUD skjermen &quot;aktiveres&quot;. Det gjøres ved å kommentere inn en linje kode i GameScreen sin show metode. hudScreen.createButtons(); for å være eksakt. Når denne koden kjøres vil den overskrive inputprosesseren fra game klassen, så det vil ikke lenger være mulig å bevege seg med piltaster osv…

1. Den første manuelle testen er om det er mulig å trykke på alle kortene. Det vil si at alle kortene har fått en listener. Her er vi ikke interessert i hva kortet får spilleren til å gjøre, men heller at den får spilleren til å gjøre noe som helst.
2. Den andre manuelle testen er at riktige bilder vises til riktige kort. Det vil si at spillerens bevegelse er den sammen som er avbildet på kortet. Når den som tester trykker på et kort som viser en pil til høyre skal spilleren endre retning til sin 


**Spawn collision**
Sørg for at ingen spillere står plassert der hvor spilleren har sitt spawn point. Ta selvmord ved f.eks å hoppe utenfor et hull. Da skal spilleren flyttes tilbake til sitt spawn point, og kunne bruke piltastene til å velge hvilken retning han skal spawne i. Confirm med ENTER.
Sørg for at annen en spiller står plasser der hvor spiller har sitt spawn point. Ta selvmord ved f.eks å hoppe utenfor et hull. Da skal spilleren plasseres i en av de ledige naboposisjonene. Bruk numpadden (tenk at 5 representerer spawnpointet til spilleren, og at den fysiske numpadden representerer området rundt) til å velge hvilken rute spilleren skal spawne i. Confirm med ENTER. Velg så retning som beskrevet i test (1).

1. Sørg for at spillerens spawn _ikke_ er plassert

## Brukerhistorier

Vi ble ikke ferdig med alle brukerhistoriene vi hadde planlagt for iterasjonene, derfor har vi noen av de samme brukerhistoriene i iterasjon 1 og 2

**Iterasjon 1: 04.03.20**

- Som spiller ønsker jeg å kunne programmere roboten min med programkort slik at jeg kan bevege roboten min
  - Arbeidsoppgaver
    - Implementere et rammeverk for programkort
    - Programkort flytter/roterer spiller
    - Spiller må kunne velge et programkort, og aktivere det
  - Akseptansekrav
    - Hvis spiller trykker på en tast knyttet til et visst programkort, og så trykker ENTER, så utføres bevegelsen knyttet til det programkortet
    - Hvis en spiller trykker på en sekvens av taster knyttet til ulike programkort, og så ENTER, så utføres bevegelsene i tilsvarende sekvens
- Som spiller ønsker jeg å ha funksjonelle hull på brettet, slik at jeg kan dytte andre roboter ned i hullene
  - Arbeidsoppgaver
    - Implementere Hull som et ITile-object
    - Implementere en movement-handler for interaksjon mellom spiller og hull. Som sender spiller til checkpoint.følgende bevegelse
    - Lage en klasse som sjekker om spilleren står på et hull (må ikke nødvendigvis være en egen klasse)
    - MovementHandler må flytte en spiller som står på et hull tilbake til spillerens backup
  - Akseptansekrav
    - Hvis en robot beveger seg over et hull, skal den flyttes tilbake til spawn. Den skal også miste en lifetoken.
- Som spiller ønsker jeg å ha samlebånd på brettet, slik at det beveger roboten min når den står oppå det
  - Arbeidsoppgaver
    - Implementere samlebånd som ITile-objekt
    - Samlebånd flytter spilleren én enhet i den retningen samlebåndet peker
    - Super-samlebånd flytter spilleren to enheter i den retningen samlebåndet peker
    - NB: NOE SOM SVINGESAMLEBÅND. HVORDAN LØSER VI DET
  - Akseptansekrav
    - Hvis spilleren står oppå et samlebånd og trykker activiation-superduper-tasten, så flyttes spilleren i retningen indikert av samlebåndet
- Som spiller ønsker ha gears på brettet, slik at det roterer roboten min når jeg står oppå det
  - Arbeidsoppgaver
    - Implementere gear som ITile-objekt
    - Gear må rotere en spiller i den retningen de indikerer
  - Akseptansekrav
    - Hvis spilleren står oppå et gear og trykker activitation-superduper-tasten, så roterer spilleren i retningen indikert av gearet
- Som spiller ønsker jeg å ha en Startmeny, slik at jeg kan trykke &quot;Play Game&quot; for å starte spillet
  - Arbeidsoppgaver
    - Lage en Screen for startmeny, med &quot;Play Game&quot; knapp
    - Play-knapp trykkes -\&gt; Screen settes til GameScreen
  - Akseptansekrav
    - Skal være en intuitiv meny, der alle knapper har forventet oppførsel.
    - Knappene skal fungere selv om vinduet til menyen blir endret
- Som spiller ønsker jeg at jeg skal kunne vinne spillet, slik at spillet kan avsluttes
  - Arbeidsoppgaver
    - Spiller må holde styr på hvilke flagg den har vært innpå
    - Spiller må bare kunne registrere flagg N dersom han allerede har registrert flagg N-1
    - Dersom en spiller har vært innom alle flaggene, avsluttes GameScreen og en &quot;You won!&quot; Screen vises
  - Akseptansekrav
    - Den første roboten som besøker alle flaggene skal vinne
    - Roboten som står igjen hvis alle andre roboter har dødd, skal vinne

**Iterasjon 2: 13.03.20**

- Som spiller ønsker ha gears på brettet, slik at det roterer roboten min når jeg står oppå det
  - Arbeidsoppgaver
    - Implementere gear som ITile-objekt
    - Gear må rotere en spiller i den retningen de indikerer
  - Akseptansekrav
    - Hvis spilleren står oppå et gear og trykker activitation-superduper-tasten, så roterer spilleren i retningen indikert av gearet
- Som spiller ønsker jeg at alle roboter og laserkanoner på brettet skal kunne avfyre lasere, slik at robotene kan bli truffet av dem
  - Arbeidsoppgaver
    - Når spilleren trykker på L skyter alle roboter og laserkanoner en laser til den treffer en vegg eller spiller.
    - Registrere hvilke roboter som blir truffet, og hvor mange ganger hver av dem blir truffet
  - Akseptansekrav
    - Roboter som blir truffet skal få damagetokens tilsvarende hvor mange lasere de blir truffet av
    - Laseren skal stoppe når den treffer objekter på brettet, for eksempel en robot eller en vegg.
- Som spiller ønsker jeg å ha samlebånd på brettet, slik at det beveger roboten min når den står oppå det
  - Arbeidsoppgaver
    - Implementere samlebånd som ITile-objekt
    - Samlebånd flytter spilleren én enhet i den retningen samlebåndet peker
    - Super-samlebånd flytter spilleren to enheter i den retningen samlebåndet peker
  - Akseptansekrav
    - Hvis spilleren står oppå et samlebånd og trykker T, så flyttes spilleren i retningen indikert av samlebåndet

**Iterasjon 3: 20.03.20**

- Som spiller ønsker jeg å motta damage tokens når jeg blir truffet av en laser, slik at roboten min kan dø
  - Arbeidsoppgaver
    - En spiller begynner med 0 damage tokens
    - Spillere får damage tokens i takt med antall lasere som treffer ham
    - En spiller som har 10 damage tokens flyttes tilbake til sin spawn
  - Akseptansekrav
    - Hvis en spiller blir truffet av 1 laser får spilleren 1 damage token.
    - Hvis en spiller blir truffet av 2 lasere samtidig får spilleren 2 damage tokens.
    - Hvis en spiller får 10 damage tokens, går i hull eller utenfor brettet tar spilleren 2 damage tokens.
- Som spiller ønsker jeg at det skal vises en rekke forskjellige kort på skjermen, slik at når jeg trykker på et av kortene utfører roboten min bevegelsen som er knyttet til kortet.
  - Arbeidsoppgaver
    - Når spiller begynner er det en overliggende meny over skjermen hvor spilleren kan trykke på kort
    - Når et kort blir trykket på utføres den bevegelsen
    - Kortene vil være tilfeldig hver gang spiller åpnes (nå i første omgang)
  - Akseptansekrav
    - Man skal kunne trykke på alle kortene
    - Roboten må gjøre riktig bevegelse (dersom det er mulig, dvs ikke bryte reglene)
- Som spiller ønsker jeg å kunne bli kastet ut av spillet hvis jeg har 0 life tokens igjen.
  - Arbeidsoppgaver
    - En spiller begynner med 3 life tokens
    - Hvis roboten dør, mister spilleren en life token
    - Hvis en spiller har 0 life tokens, fjernes han fra spillet.
  - Akseptansekrav
    - Hvis en spiller får 10 damage tokens mister spilleren 1 life token
    - Hvis en spiller treffer et hull eller går utenfor banen mister spilleren 1 life token