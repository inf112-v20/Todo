## **Obligatorisk oppgave 2**
**Deloppgave 1: Prosjekt og prosjektstruktur**

*Hvordan fungerer rollene i teamet?*

I praksis har vi stort sett ikke merket til rollebesetningen. Det viser seg at alle på gruppen er flinke til å ta initiativ til møter, delege av oppgaver etc, så vi har ikke ligget spesielt merke til at vi har en teamleder. Kundekontakten vår har ikke vært i kontakt med kunden, siden vi ikke har hørt noe eksplisitt innkalling fra kunden. Likevel kommer antageligvis dette til å endre seg etterhvert som prosjektet øker i kompleksitet. Derfor velger vi å beholde rollene akkurat slik de er nå.

*Trenger dere andre roller? Skriv ned noen linjer om hva de ulike rollene faktisk innebærer for dere.*

Vi vurderer å utnevne en grafisk designer som skal være ansvarlig for design av egentilpasset tilesheets for spillbrettet og for spillerne (roboter). Den som har denne rollen vil også styre hvordan menyen vil se ut senere. Vi venter forøvrig med dette, da vi ikke har kommet langt nok i utviklingsprosessen for at dette skal bli relevant.
 
*Er det noen erfaringer enten team-messig eller mtp prosjektmetodikk som er verdt å nevne?*

Vi har erfart at bruk av prosjekt-brettet fra scrum er veldig praktisk når det kommer til å holde oversikt over hva alle de andre på gruppen jobber med, samt å finne nye oppgaver en selv kan jobbe med. 
Teamet er svært effektive under sprints og får gjort svært mange punkter på prosjekt-brettet.

*Synes teamet at de valgene dere har tatt er gode? Hvis ikke, hva kan dere gjøre annerledes for å forbedre måten teamet fungerer på?*

Denne første perioden i gruppearbeidet har vært en læringsprosess for oss, vi har gjort mange tabber med organisering av kodebasen og hvordan vi har organisert oss som et team. Fremover ønsker vi å få istand et bedre system på hvordan vi delegerer arbeidsoppgaver. Vi har tenkt å bruke møtene til å planlegge hvem som tar ansvar for de større gjøremålene som er planlagt, og så bruker vi assignees-tagen til issues på github til å holde styr på hvem som er tildelt hvilket arbeid. Vi vil også nytte møtene i større grad til å planlegge hvordan strukturen på koden vår skal være.

*Hvordan er gruppedynamikken?*

Dynamikken i gruppen er bra. Vi kommuniserer enkelt med hverandre, både over nett og når vi snakker sammen. Støter vi på en utfordring vi sliter å få til, tar vi gjerne kontakt med andre gruppemedlemmer om råd. Eventuelt tar vi opp sånne ting i plenum på gruppemøtene. I så fall er alle villige til å komme med innspill for å komme frem til best mulig løsning. Vi liker å løse utfordringer sammen, og det gir også ofte det beste resultatet. Ellers er stemningen lett og uformell, og vi trives i hverandres selskap. 

*Hvordan fungerer kommunikasjonen for dere?*

Gruppen kommuniserer ofte med hverandre, og alle gruppemedlemmer deltar aktivt i planleggingen av prosjektet. Vi bruker Slack og Messenger som kommunikasjonsmidler, og ellers møtes vi personlig. På Slack avtales møter, og viktige dokumenter og lenker holdes orden på. Vi har en uformell gruppesamtale på Messenger hvor vi kan ta opp mer “casual” temaer dersom det skulle være behov for det.
Gruppemedlemmene treffes skremmende ofte utenfor planlagte tidsrom; i forelesninger enkelte av oss har felles, og tilfeldig på lesesalen hvor mange av oss tilbringer en del tid. Så vi har det enkelt for å slå av en prat om nye prosjektutfordringer også utenfor gruppemøtene og kommunikasjonsmidlene.
Vi forsøker også å ha en åpen holdning til spørsmålsstilling om hvordan koden fungerer og henger sammen, og også kritikk av hverandres kodedesign, navngiving, mm. Lurer en av oss på hvordan koden en annen skrev fungerer, er det bare å spørre. Vi er alle opptatt av at alle skal forstå mest mulig av koden. Vi er enige om at spesielt kritikk kan være utfordrende, men nødvendig for å oppnå best mulig helhetlig design. Da må dette naturligvis gjøres på en konstruktiv måte. Nå har vi ikke opplevd noe særlig til akkurat dette, men vi er enige om at det bør være en mulighet.


**Gjør et kort retrospektiv hvor dere vurderer hva dere har klart til nå, og hva som kan forbedres. Dette skal handle om prosjektstruktur, ikke kode. Dere kan selvsagt diskutere kode, men dette handler ikke om feilretting, men om hvordan man jobber og kommuniserer.**

Vi hadde i utgangspunktet bestemt oss for ha et løst forhold til valg av prosjektmetodikk , men å spesielt prøve ut følgende prinsipper fra smidig utvikling: parprogrammering, scrum sprints med en slags scrum master, og testdrevet utvikling.

*Parprogrammering*

Av disse tre prinsippene har parprogrammering klart fungert best. Vi opplever flere positive sider ved denne metoden. For det første har det fungert bra for å oppdatere medlemmer om hvordan deler av koden de ikke har sett før fungerer. For det andre finner vi gjerne flere løsninger på et problem, drøfter de ulike løsningene, og bestemmer oss for løsningen vi liker best.

*Scrum sprints*

Etter vi hadde laget user stories og fordelt dem i arbeidsoppgaver, bestemte vi oss raskt for å la kommende sprint vare i kun én uke, ettersom oppgavene virket ganske simple. Dette viste seg på en måte å ikke stemme. Vi brukte mye av den første uken bare på finne ut hvordan vi skulle sammenkoble LibGDX og forretningslogikk. Uforutsett mye tid gikk til lesing og tutorials, og vi kom oss ikke raskt i gang med selve kodingen. Vi bestemte oss derfor bare for å utvide sprinten med en uke. Da klarte vi å bli ferdig med arbeidsoppgavene med god margin.

*Forbedringspotensiale 1*

Vi bør i neste sprint på forhånd bestemme oss for hvem som skal gjøre hvilke arbeidsoppgaver, i stedet for at noen bare tar første og beste oppgave. Slik får vi bedre kontroll og oversikt over hva alle medlemmer skal gjøre i denne omgangen, samtidig som at det er en fin måte å fordele arbeidsoppgaver jevnt mellom medlemmene.

*Forbedringspotensiale 2*

da vi nærmet oss slutten på sprinten, ble noen av oss utålmodige og endte opp med å legge flere arbeidsoppgaver inn i scrumboardet uten å la dette gå gjennom gruppediskusjonen. Dette virket som en naturlig ting å gjøre på dette tidspunktet, men vi innser nå tilslutt at vi ble stående uten tilhørende user stories, og at alle nå sitter med litt forskjellige oppfatninger om hva som egentlig bør gjøres og prioriteres til neste sprint. Vi burde heller ha holdt oss skikkelig til sprintmodellen.

*Testdrevet utvikling*

Testdrevet utvikling har vi egentlig forsøkt ut i liten grad. De viktigste klassene som har kommet frem under denne sprinten er avhengig av å instansiere et TiledMap, noe som gir NullPointerException når det gjøres i test-klassene. Dermed har ikke det vært mulig å lage sentrale tester. Vi planlegger å implementere en måte for oss å kjøre applikasjonen vår headless slik at vi faktisk kan lage automatiske tester for alle klassene som benytter TiledMap, men vi har nedprioritert dette og fokusert på å faktisk levere et fungerende produkt til fristen for oblig2. En måte å kjøre programmet headless vil være høy prioritet når vi begynner arbeidet mot neste oblig.


Alt i alt: vi har gått fra å ha et løst forhold til prosjektmetodikk til nå å bestemme oss for å faktisk ta i bruk scrum. I den sammenheng har vi tre konkrete forbedringspunkter, som er utdypet ovenfor:
1. Delegering av arbeidsoppgaver skal skje like etter opprettelsen av dem
2. Helhjertet holde oss til sprintmodellen, og ikke lage nye arbeidsoppgaver utenfor scrum-møtet (begynnelsen av sprinten)
3. Ta testdrevet utvikling i bruk. Løse TiledMap/headless-problemet hvis det er det som skal til

*Forklaring av skjevfordelt commithistorikk*

Av commithistorikken vår kan det virke som om kun noen av oss har bidratt til utviklingen av koden. Dette er ikke tilfellet, da vi i stor grad har drevet med parprogrammering. Vi har ikke giddet å drive med rotering av PCer vi jobber på for å tegne et kunstig bilde av bidragsmangfoldighet. Bunnlinjen her er at alle bidrar gjennom parprogrammering.

**Møtereferater**

*Møte/gruppetime 21.20.2020 (Eskil, Øyvind, Alvar)*
Gruppen arbeidet med å finne brukerhistorier for ønsket oppførsel til neste innlevering.

*Møte 25.02.2020 (Alle gruppemedlemmer deltok)*
Siden flere var borte forrige uke gikk vi gjennom koden i plenum, og fikk alle up to speed på oblig 2, og hva vi må gjøre annerledes (flere tester f.eks)  og hvordan vi skal komme videre med koden. Etter møtet skled vi naturlig inn i en slags sprint og fikk gjort mange av punktene på prosjekt-brettet.

*Møte 26.02.2020 (Alle gruppemedlemmer deltok)*
Vi jobbet videre med kodingen, siden flere jobbet med ulike deler snakket vi en del sammen. En bad merge oppstod og ble pushet til master, slik at produktet krasjet ved oppstart. Dette ble raskt fikset i plenum, men vi kjente alle litt på (og hadde litt godt av) panikken som følger av en bad merge.

*Møte/Gruppetime 28.02.2020. (Eskil, Øyvind, Alvar og Pål deltok)*
Vi arbeidet med å fullføre den andre obligatoriske innleveringen. 



**Deloppgave 2: Krav**

*For hvert krav dere jobber med, må dere lage 1) ordentlige brukerhistorier, 2) akseptansekriterier og 3) arbeidsoppgaver. Husk at akseptansekriterier ofte skrives mer eller mindre som tester*

* Som spiller ønsker jeg å ha medspiller på brettet, slik at jeg har noen å spille med.
   	Arbeidsoppgaver:
    * Få på plass enda et Player-objekt som representerer den nye spilleren
    * Kunne lage flere unike Player-objekt som representerer en ny spiller
    * InputHandler for Spillklassen som håndterer inputs for alle de forskjellige playersene
    
    Akseptansekrav: Hvis jeg starter spillet skal jeg se en annen spiller på kartet

* Som spiller ønsker jeg at jeg kan dytte et robot på kartet i den retningen jeg beveger meg, slik at roboter ikke kan stå oppå hverandre.
  	Arbeidsoppgaver:
    * Klasse som sørger for at dersom en spiller beveger seg mot en annen spiller, så beveges begge spillerne i den retningen
    
    Akseptansekrav: Hvis jeg prøver å bevege meg inn i en robot, skal roboten bevege seg i samme retning som roboten min beveger seg. Dette gjelder også hvis flere roboter står på rekke. De skal heller ikke bli dyttet hvis de treffer en vegg.

* Som spiller ønsker jeg at det skal være vegger på kartet, slik at roboten min blir stoppet om den forsøker å bevege seg der.
  Arbeidsoppgaver:
    * Generell klasse for alle slags mulige tiles på det statiske brettet
    * Veggobject (med rotasjon?)
    * En eller annen klasse som håndterer kollisjon
    
    Akseptansekrav: Hvis roboten min beveger prøver å bevege seg inn i en vegg, skal den ikke bevege seg.


* Som spiller ønsker jeg at roboten min plasseres på checkpoint dersom den beveger seg ut av brettet, slik at den ikke står plassert ulovlig.
  Arbeidsoppgaver:
    * Playerklassen må ha en origin som den kan respawne på
    * Klasse som skjekker om bevegelsen tar spiller ut av kartet, og som flytter spilleren til spawn
    
    Akseptansekrav: Dersom roboten min beveger seg ut av brettet så skal roboten min bli plassert på chechpointet sitt. 


*Dersom dere har oppgaver som dere skal til å starte med, hvor dere har oversikt over både brukerhistorie, akseptansekriterier og arbeidsoppgaver, kan dere ta med disse i innleveringen også.*

* Som spiller ønsker jeg at roboten min skal rotere dersom roboten stiller seg på et tannhjul
 Arbeidsoppgaver: 
    * Akseptansekrav: Dersom roboten stiller seg på et tannhjul seg roboten rotere i samme retning som tannhjulet

* Som spiller ønsker jeg at roboten min skal bevege seg i retningen av et samlebånd dersom den stiller seg på et samlebånd
    * Akseptansekrav: Dersom en robot stiller seg på et samlebånd skal den bevege seg i retningen av samlebåndet


**Forklar kort hvordan dere har prioritert oppgavene fremover.**

Vi har prioritert oppgaver som er direkte knyttet med spillbrettet og robotens bevegelse. Det vil si oppgaver som angår funksjonalitet. På scrumbrettet har vi fortsatt en del oppgaver knyttet til dette som vi må håndtere før vi kan begynne på nye oppgaver. Etter dette vil vi håndtere oppgaver som programkort og faser og runder.


*Forklar kort hvilke hovedkrav dere anser som en del av MVP og hvorfor. Hvis det er gjort endringer i rekkefølge utfra hva som er gitt fra kunde, hvorfor er dette gjort?*

Vi anser fortsatt MVP som det absolutte minimum av funksjonalitet som vi trenger for at spillet kan fungere, MVP er da:
* Et Kart som inneholder alle spill-objektene vi trenger for å spille RoboRally. Kartet må altså inneholde:
    * Vegger
    * Laser
    * Flag
    * Hull
    * Tannhjul
    * Transportbånd
    * Skiftenøkkel
    * Roboter
* En overordnet spill-klasse som behandler spill-logikk og viser kartet grafisk til brukeren.
* En Robot som kan
    * Bevege seg
    * Miste liv
    * Dø
    * Gjennoppstå
    * Powerdown
* En spiller som kan:
    * Få utdelt programkort
    * Legge ned et program
    * Tape/vinne
*   Brukergrensesnitt som lar brukeren:
    *   Se spill-brettet grafisk
    *   programmere roboten sin
    *   velge powerdown
*   Rammeverk for lokal multiplayer

**Oppdater hvilke krav dere har prioritert, hvor langt dere har kommet og hva dere har gjort siden forrige gang.**

Fram til nå har vi prioritert oppgaver direkte knyttet til robotenes bevegelse. Vi har kommet godt i gang med dette og har allerede implementert funksjonalitet som:


*   BackUp
*   Kan falle ut av banen, og respawne på backup
*   Vegger (i alle mulige retninger, og kombinasjoner av dem)
*   Kan dytte roboter
    *   Roboter kan ikke dyttes gjennom vegger

Vi har valgt å legge alt av grafikk til side for denne innleveringen, og heller prioritere kode-aspektene av oppgaven.

**Husk å skrive hvilke bugs som finnes i de kravene dere har utført (dersom det finnes bugs). **

Vi har naturligvis den “medfødte” buggen/feilmeldingen fortsatt dersom man bruker nyere versjoner av java enn java 8. Det vil si “_WARNING: An illegal reflective access operation has occurred_”

Ellers vet vi om én bug. La oss si at spilleren kontrollerer robot1, og at en av de to andre er robot2. La oss si at robot2 har sin spawn ved siden av “kanten” til mappet. Det betyr at dersom robot2 beveger seg én enhet i retning kanten, vil den respawne der den stod, som om ingenting har skjedd. Buggen inntreffer om robot1 “skubber” robot2 til sin spawn, og at robot1 så dytter robot2 av mappet. Da blir robot1 stående der hvor robot2 skal stå. Den logiske posisjonen til begge robotene er den samme, men robot1 tegnes på kartet. Om robot1 nå flytter seg, er ikke robot2 lengre grafisk tilstede. Men robot2 er logisk til stede. Robot2 har altså blitt usynlig.

Denne buggen virker viktig å få gjort noe med nå, men det er den egentlig ikke. I det virkelige spillet blir aldri robotenes spawn plasseres inntil brettets “kant”, så problemet vil ikke oppstå. 


**Deloppgave 3: Kode**

**Prosjektet skal kunne bygge, testes og kjøres på Linux, Windows og OSX. **

Prosjektet kjører fint i windows og linux. Vi har ikke hatt muligheten til å teste det for OSX, men ser ingen grunn til at det ikke skulle fungere der.

**Testing:**

Vi har inkludert enkle men omfattende tester av spillerens rotasjon. Og at vegger returnerer riktig attributter.

Vi har hatt problemer med å legge til tester som inkluderer brettet da brettet er direkte knyttet til grafikken. For å fikse dette kreves det av vi implementerer et headless rammeverk noe vi enda ikke har prioritert. Dette har vi valgt å legge til side for denne implementasjonen siden vi har vært så fokuserte på å implementere robot-funksjonalitet som enkelt kan testes med manuelle tester. Dessuten vil vi måtte abstrahere en del kode fra player og movementhandler klassene, noe som ville ført til at vi måtte skrive testene på nytt igjen senere uansett. Så istedenfor å bruker overflødig tid på det har vi fokusert på funksjonalitet og manuelle tester.

Vi har laget et environment (dvs map) for manuelle tester. I og med at vi ikke har implementert funksjonalitet for gears, lasere, liv, eller hull på mappen er det enda ganske begrenset hva som fungerer som det skal på banen. 

**Manuelle tester:**


1. _Grunnleggende bevegelse_

    Bruker piltastene til å teste robotens bevegelse. 

    1. Der pil-opp refererer til å bevege seg framover
    2. Pil-ned beveger seg bakover
    3. Pil-høyre roterer roboten mot høyre
    4. Pil-venstre roterer roboten mot venstre. 
2. _Grunnleggende vegg-oppførsel_

    Roter spilleren direkte mot en vegg. Dersom det er en:

    5. Vegg på venstre side og du beveger deg mot venstre bør roboten ikke beveges
    6. Vegg på høyre side og du beveger deg mot høyre bør roboten ikke beveges
    7. Vegg over roboten og du beveger deg oppover bør roboten ikke beveges
    8. Vegg under roboten og du beveger deg nedover bør roboten ikke beveges
3. _Dytting av andre roboter_

    Plasser spilleren direkte til høyre eller venstre for en av de andre robotene på banen, beveg deg så mot roboten. Forventet resultat vil være at begge robotene beveger seg i samme retnings som piltasten.

4. _Dytting av flere roboter_

    Plasser spilleren direkte over eller under begge de to andre robotene på banen. Beveg deg så mot robotene. Det forventede resultatet vil være at alle robotene beveger seg i samme retning som piltasten

5. _Dytting av flere roboter mot vegg_

    Repeter test 4, men plasser robotene slik at roboten lengst vekke fra spilleren er inntil en vegg. Beveg deg nå mot robotene. Det forventede resultatet vil være at ingen av robotene beveger seg.

6. _Grunnleggende backup-oppførsel_

    Flytt roboten fra startpunktet hele veien opp til toppen av banen. Der finnes den glippe i veggene. Når roboten beveger seg ut av banen er det forventet at roboten skal flyttes tilbake til backup lokasjonen sin. Backup lokasjonen vil “by default” være lokasjonen roboten startet på. Vi har valgt å inkludere muligheten til å endre backupen ved å trykke på C, og muligheten til å flytte roboten til checkpoint ved å trykke på mellomrom.

7. _Backup-oppførsel for “ikke-aktive” roboter_

    Dytt en annen robot helt til toppen av banen, samme sted som i test 6. Dytt så denne roboten utenfor banen. Forventet resultat er at den dyttende roboten flyttes til sin backup-posisjon, mens spillerens robot flyttes der hvor den dyttende stod i utgangspunktet.    	







